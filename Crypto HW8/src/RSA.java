import java.math.BigInteger;
import java.security.SecureRandom;


public class RSA {
	
	public static BigInteger[] privateKey;
	public static BigInteger[] publicKey;
	
	//public key e and n
	public static BigInteger eAnaHoan;
	public static BigInteger nAnaHoan;
	static {
		eAnaHoan = new BigInteger("41696152302625599525204629055962469598348662957970455208354398656248859312443219775735533582570341054207523272038826934682136864094617100386238528847317114906122796954370607895388249349896398544146166005418646839885332781793678257628779793958511763706012582896262227787436012495391208621563947354492722605455");
		nAnaHoan = new BigInteger("16127971557512909018189620996631516843105609694005016886485656525675814193168194657201468264366991981947928529494143349515583015590884464155794397676183364231718803545713923264270127587267936267237001447967896438706259335825838983394977010305446943327565698699946554408317197333826589450014512705730133796618107546013552055593558714956671605000151637885429613922416932760192343965730356284496588367698589125263958643220164206945000517308035631394233644347345049381253375224432095679556340940837678574310107732512351202583081421383431585358811721919189191600060250761289953682989698704585903556329027458157473346865301");
	}
	
	//Signed message
	public static BigInteger C;
	static {
		C = new BigInteger("461512572493555386000924296873016987184980748939869214341495544433328749093451312919214997356743435671590323538686123633732006326544427157304165907669286444685617696856824003727217166543625232906337448119162692801659178303179302847925480971218233065624226100066138517630789561735126104361464662119581459831654728071258857497337814485657174862817748189188181776059356802282883912983117308761447611965738665511980202507892042689230466040519537215595331317340502192255415157159956085750047270467655169112558709860357090318144741589255382507471281759040159746842561213856704851459336770900783719545340488748458111862019695789807647245560559691248562041222998730214624274764656668403370684724486415330670950433380197514822678163529830042674408024507882319665997927254637596113914899373482163112559157859112464822463342851930745770560272261195034552285596466426832677151781412516571546610310629588486338839762087539792805184077156164298851474816290211191831142101329522343094378649164577307137959612443226450899590658569698214960837093509970368072197467630171587748526165112343567535575281270869908486367845097727222520652072358790640204866289958181600434295611441434755778305622710455140551010972023793304769877366054810031591353135566207");
	}
	
	public void generateKey() {
		BigInteger p = BigInteger.probablePrime(1024, new SecureRandom());
		BigInteger q = BigInteger.probablePrime(1024, new SecureRandom());
		BigInteger temp1 = p.subtract(BigInteger.ONE);
		BigInteger temp2 = q.subtract(BigInteger.ONE);
		BigInteger fn = temp1.multiply(temp2);
		BigInteger e = findE(fn);
		BigInteger d = e.modInverse(fn);
		
		BigInteger n = p.multiply(q);
		publicKey = new BigInteger[2];
		publicKey[0] = e;
		publicKey[1] = n;
		privateKey = new BigInteger[2];
		privateKey[0] = d;
		privateKey[1] = n;

	}
	
	private BigInteger findE(BigInteger fn) {

		while (true) {
			BigInteger e = new BigInteger(1023, new SecureRandom());
			if (fn.gcd(e).equals(BigInteger.ONE)) return e;
		}
	}
	

}
